#  Terraform Boostrap Resources

The client requires that the infrastructure be built collaboratively by a team with limited cloud experience. To ensure safe and remote collaboration, Terraform must use a **remote backend** that supports **state locking** and **versioning**.

The task explicitly references AWS best practices for managing Terraform state:
> [Best practices for managing Terraform state files in AWS CI/CD pipeline](https://aws.amazon.com/blogs/devops/best-practices-for-managing-terraform-state-files-in-aws-ci-cd-pipeline/)

---

##  Decision

Provision foundational backend resources using a single CloudFormation stack:

- **S3 Bucket** for storing Terraform state files
- **DynamoDB Table** for state locking

This avoids circular dependencies and aligns with the client's expectation of remote, conflict-free collaboration.

---

##  Resources Created

### CloudFormation Stack: `terraform-backend-bootstrap`
- Template file: `bootstrap/infra-bootstrap.yaml`
- Region: `us-east-1`

### S3 Bucket: `terraform-state-bucket`
- Versioning: Enabled
- Encryption: AES256
- Public Access: Blocked

### DynamoDB Table: `terraform-locks`
- Partition Key: `LockID` (String)
- Billing Mode: PAY_PER_REQUEST

---

## CloudFormation Deployment Command

```bash
aws cloudformation deploy \
  --stack-name terraform-backend-bootstrap \
  --template-file bootstrap/infra-bootstrap.yaml \
  --region us-east-1 \
  --capabilities CAPABILITY_NAMED_IAM

aws cloudformation describe-stacks \
  --stack-name terraform-backend-bootstrap \
  --region us-east-1

```

> This command provisions both the S3 bucket and DynamoDB table in one atomic operation.

---

## Terraform Backend Configuration

Place this block in `backend.tf` inside each environment folder (`qa/`, `prod/`):

```hcl
terraform {
  backend "s3" {
    bucket         = "terraform-state-bucket"
    key            = "env/${terraform.workspace}/terraform.tfstate"
    region         = "us-east-1"
    dynamodb_table = "terraform-locks"
    encrypt        = true
  }
}
```

---

## Rationale

- **Why not use Terraform to create these resources?**
  Terraform cannot manage its own backend without bootstrapping issues. Creating the bucket and table manually ensures stability and avoids circular logic.

- **Why use CloudFormation?**
  CloudFormation provides reproducibility, traceability, and aligns with AWS-native governance. It also allows future automation of foundational resources.

- **Why use workspaces in the key path?**
  This allows separation of state files for QA and Production environments, supporting multi-environment workflows.

---

## Implications

- All team members can safely collaborate using `terraform plan` and `terraform apply` without corrupting state.
- The backend is reusable across projects and environments.
- This setup complies with AWS Well-Architected Framework pillars: **Operational Excellence**, **Reliability**, and **Security**.
